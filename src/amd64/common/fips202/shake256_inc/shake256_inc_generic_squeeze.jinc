/// SQUEEZE WITH TEMPLATES ///////////////////////////////
inline
fn __keccak_inc_squeeze_copy_from_state_t(
  reg ptr u8[LEN] out,
  reg u64 outlen,
  reg u64 limit,
  reg ptr u64[26] state,
  reg u64 offset_state,
  reg u64 offset_out)
  ->
  reg u64,
  reg ptr u8[LEN],
  reg u64,
  reg u64
{
  reg u64 i index z;
  reg u8 value;
  reg bool cond;

  i = 0;
  while { cond = std::cond::cond_u64_a_below_b_and_a_below_c(i, outlen, limit); } (cond)
  {
    value = state[u8 offset_state];

    z = offset_out;
    z += i;
    out[z] = value;
    offset_state += 1;
    i += 1;
  }

  offset_out += i;
  outlen -= i;
  index = limit - i; // register renaming

  return index, out, outlen, offset_out;
}

inline
fn __keccak_inc_squeeze_t(
  reg ptr u8[LEN] out,
  reg ptr u64[26] state,
  reg u64 rate
) -> reg ptr u8[LEN], reg ptr u64[26]
{
  reg u64 limit  index outlen;
  reg u64 offset_state offset_out;
  stack u64 s_outlen s_rate s_offset_out;
  stack ptr u8[LEN] s_out;

  reg ptr u64[25] non_absorbed_byes;
  
  outlen = LEN;
  offset_out = 0;

  // first consume any bytes we still have sitting around
  limit = state[25];
  offset_state = rate;
  offset_state -= state[25];

  index, out, outlen, offset_out = __keccak_inc_squeeze_copy_from_state_t(out, outlen, 
                                                                                  limit, state, 
                                                                                  offset_state, 
                                                                                  offset_out);

  state[25] = index;

  // then squeeze the remaining necessary blocks
  s_rate = rate;

  while( outlen > 0 )
  {
    s_out = out;
    s_outlen = outlen;
    s_offset_out = offset_out;


    non_absorbed_byes = state[0:25];
    non_absorbed_byes = _keccakf1600_ref1(non_absorbed_byes);
    state[0:25] = non_absorbed_byes;

    out = s_out;
    outlen = s_outlen;
    limit = s_rate;
    offset_state = 0;
    offset_out = s_offset_out;

    index, out, outlen, offset_out = __keccak_inc_squeeze_copy_from_state_t(out, outlen, 
                                                                                    limit, state, 
                                                                                    offset_state, 
                                                                                    offset_out);

    state[25] = index;
  }

  return out, state;
}

inline
fn __shake256_inc_squeeze_t(
  reg ptr u8[LEN] out,
  reg ptr u64[26] state
) -> reg ptr u8[LEN], reg ptr u64[26]
{
  reg u64 rate;

  rate = (1088/8); // = 136

  out, state = __keccak_inc_squeeze_t(out, state, rate);

  return out, state;
}
