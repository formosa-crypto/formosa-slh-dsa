/// ABSORB WITH TEMPLATES //////////////////////////////////////
inline
fn __keccak_inc_absorb_t(
  reg ptr u64[26] state,
  reg ptr u8[LEN] in,
  inline int rate
) -> reg ptr u64[26]
{
  reg u64 i inlen offset_in;

  reg u64 t u v z;

  stack u64 s_inlen s_i s_offset_in s_t s_u s_v s_z;
  stack ptr u8[LEN] s_in;

  reg ptr u64[25] non_absorbed_byes;

  offset_in = 0;
  inlen = LEN;

  t = inlen;
  t += state[25]; // // t holds the value of inlen + state[25]

  while (t >=u rate) {
    i = 0;

    t = rate;
    t -= state[25];

    while (i < t) {
      // s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
      t = state[25];
      t += i;

      u = t;
      t >>= (3 & 63); // index: s_inc[25] + i) >> 3

      u &= 0x07;
      ?{}, u = #SHL(u, 3);

      // z = in;
      // z += offset_in;
      // z += i;
      z = offset_in;
      z += i;

      v = (64u) in[z];
      v <<= (u & 63);

      state[t] ^= v;

      // t : (state[25] + i) >> 3
      // u : 8 * ((state[25] + i) & 0x07)
      // z : i (after adjsuting for offset)
      // v : (uint64_t) in[i] << (8 * ((state[25] + i) & 0x07))

      t = rate;
      t -= state[25];

      i += 1;
    }

    t = rate;
    t -= state[25];
    inlen -= t;      // mlen -= (size_t)(r - s_inc[25]);
    offset_in += t;  // m += r - s_inc[25];

    state[25] = 0;

    //////////////////// PERMUTE STATE //////////////////////////////////////
    s_in = in;
    s_inlen = inlen;
    s_i = i;
    s_offset_in = offset_in;
    s_t = t;
    s_u = u;
    s_v = v;
    s_z = z;

    non_absorbed_byes = state[0:25];
    non_absorbed_byes = _keccakf1600_ref1(non_absorbed_byes);
    state[0:25] = non_absorbed_byes;

    in = s_in;
    inlen = s_inlen;
    i = s_i;
    offset_in = s_offset_in;
    u = s_u;
    v = s_v;
    z = s_z;
    //////////////////// PERMUTE STATE //////////////////////////////////////

    // To compute the loop condition
    t = inlen;
    t += state[25]; // // t holds the value of inlen + state[25]
  }

  // second for loop
  i = 0;
  while (i < inlen) {
    // s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
    t = state[25];
    t += i;
    t >>= (3 & 63); // index: s_inc[25] + i) >> 3

    u = state[25]; 
    u += i;        
    u &= 0x07;
    ?{}, u = #SHL(u, 3);

    // z = in;
    // z += offset_in;
    // z += i;
    z = offset_in;
    z += i;

    v = (64u) in[z];
    v <<= (u & 63);

    state[ t] ^= v;

    // t : (state[25] + i) >> 3
    // u : 8 * ((state[25] + i) & 0x07)
    // z : i (after adjsuting for offset)
    // v : (uint64_t) in[i] << (8 * ((state[25] + i) & 0x07))

    i += 1;
  }

  state[25] += inlen;

  return state;
}

#[returnaddress="stack"]
fn _shake256_inc_absorb_t(
  reg ptr u64[26] state,
  reg ptr u8[LEN] in
) -> reg ptr u64[26]
{
  inline int rate;

  rate = (1088/8); // = 136

  state = __keccak_inc_absorb_t(state, in, rate);
  return state;
}

inline
fn __shake256_inc_absorb_t(
  reg ptr u64[26] state,
  reg ptr u8[LEN] in
) -> reg ptr u64[26]
{
  state = state;
  in = in;

  state = _shake256_inc_absorb_t(state, in);

  state = state;
  in = in;

  return state;
}

